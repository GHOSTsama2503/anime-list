// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: animes.sql

package queries

import (
	"context"
	"database/sql"
)

const createAnime = `-- name: CreateAnime :one
INSERT INTO animes (
    id_al,
    title_romaji,
    title_native,
    title_english,
    format,
    status,
    description,
    start_date,
    end_date,
    season,
    season_year,
    episodes,
    duration,
    banner_image,
    st_image,
    group_position
)
VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
RETURNING id, id_al, title_romaji, title_native, title_english, format, status, description, start_date, end_date, season, season_year, episodes, duration, banner_image, st_image, group_position
`

type CreateAnimeParams struct {
	IDAl          int64
	TitleRomaji   string
	TitleNative   sql.NullString
	TitleEnglish  sql.NullString
	Format        string
	Status        string
	Description   string
	StartDate     string
	EndDate       string
	Season        string
	SeasonYear    sql.NullInt64
	Episodes      int64
	Duration      int64
	BannerImage   sql.NullString
	StImage       string
	GroupPosition sql.NullInt64
}

func (q *Queries) CreateAnime(ctx context.Context, arg CreateAnimeParams) (Anime, error) {
	row := q.db.QueryRowContext(ctx, createAnime,
		arg.IDAl,
		arg.TitleRomaji,
		arg.TitleNative,
		arg.TitleEnglish,
		arg.Format,
		arg.Status,
		arg.Description,
		arg.StartDate,
		arg.EndDate,
		arg.Season,
		arg.SeasonYear,
		arg.Episodes,
		arg.Duration,
		arg.BannerImage,
		arg.StImage,
		arg.GroupPosition,
	)
	var i Anime
	err := row.Scan(
		&i.ID,
		&i.IDAl,
		&i.TitleRomaji,
		&i.TitleNative,
		&i.TitleEnglish,
		&i.Format,
		&i.Status,
		&i.Description,
		&i.StartDate,
		&i.EndDate,
		&i.Season,
		&i.SeasonYear,
		&i.Episodes,
		&i.Duration,
		&i.BannerImage,
		&i.StImage,
		&i.GroupPosition,
	)
	return i, err
}

const getAnime = `-- name: GetAnime :one
SELECT id, id_al, title_romaji, title_native, title_english, format, status, description, start_date, end_date, season, season_year, episodes, duration, banner_image, st_image, group_position FROM animes
WHERE id = ?
`

func (q *Queries) GetAnime(ctx context.Context, id int64) (Anime, error) {
	row := q.db.QueryRowContext(ctx, getAnime, id)
	var i Anime
	err := row.Scan(
		&i.ID,
		&i.IDAl,
		&i.TitleRomaji,
		&i.TitleNative,
		&i.TitleEnglish,
		&i.Format,
		&i.Status,
		&i.Description,
		&i.StartDate,
		&i.EndDate,
		&i.Season,
		&i.SeasonYear,
		&i.Episodes,
		&i.Duration,
		&i.BannerImage,
		&i.StImage,
		&i.GroupPosition,
	)
	return i, err
}

const getAnimeByAnilistId = `-- name: GetAnimeByAnilistId :one
SELECT id FROM animes
WHERE id_al = ?
`

func (q *Queries) GetAnimeByAnilistId(ctx context.Context, idAl int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getAnimeByAnilistId, idAl)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getAnimes = `-- name: GetAnimes :many
SELECT id, id_al, title_romaji, title_native, title_english, format, status, description, start_date, end_date, season, season_year, episodes, duration, banner_image, st_image, group_position FROM animes
ORDER BY title_romaji COLLATE NOCASE ASC
LIMIT ?
OFFSET ?
`

type GetAnimesParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) GetAnimes(ctx context.Context, arg GetAnimesParams) ([]Anime, error) {
	rows, err := q.db.QueryContext(ctx, getAnimes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.ID,
			&i.IDAl,
			&i.TitleRomaji,
			&i.TitleNative,
			&i.TitleEnglish,
			&i.Format,
			&i.Status,
			&i.Description,
			&i.StartDate,
			&i.EndDate,
			&i.Season,
			&i.SeasonYear,
			&i.Episodes,
			&i.Duration,
			&i.BannerImage,
			&i.StImage,
			&i.GroupPosition,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
